# Cursor Rules for TES Arena-Style C++ Framework

## Primary Goal

Build a minimal TES Arena-style C++ framework that compiles to both native desktop and WebAssembly, following vibecoding principles: build only what you need, start with the game, let it shape the framework.

## Core Principles: Vibecoding & AI-Optimized Development

### Vibecoding Philosophy
1. **Build only what you need**: Don't add framework features until the game requires them
2. **Start with the game**: Write game code first, extract framework code when patterns emerge
3. **Let the game shape the framework**: Framework grows organically from game needs
4. **No premature optimization**: Keep code simple until performance becomes an issue
5. **WASM-first mindset**: Code should work in both native and WASM without modification

### 1. Language: C++17
**Rule:**
- Use C++17 standard (CMake requirement)
- Prefer structs + functions over classes where possible
- Use `#ifdef __EMSCRIPTEN__` for WASM-specific code paths
- No exceptions in framework code (use error codes or `std::optional`)
- Keep everything header-only where possible (except platform code)

**Why:**
- C++17 provides modern features without complexity
- Structs + functions are simpler and more AI-friendly
- Header-only code reduces compilation complexity
- No exceptions ensures WASM compatibility
- AI can easily understand and modify simple C++ patterns

### 2. Rendering: Raycaster (OpenGL ES 2.0)
**Rule:**
- Use classic Wolf3D-style raycaster algorithm
- OpenGL ES 2.0 compatible (for WASM WebGL)
- Render one vertical column per screen pixel
- Use DDA (Digital Differential Analyzer) for grid traversal
- Support wall textures, floor/ceiling rendering, sprite billboarding

**Why:**
- Perfect for TES Arena-style retro aesthetic
- Simple algorithm that AI can understand and modify
- Works identically in native and WASM (WebGL)
- Low performance requirements
- Classic, well-documented approach

### 3. Build System: CMake + vcpkg
**Rule:**
- Use CMake 3.20+ for build configuration
- Use vcpkg for dependency management (SDL2, stb_image)
- Support both native and WASM builds via CMake options
- Use Emscripten toolchain for WASM compilation
- Keep build configuration simple and clear

**Why:**
- Standard C++ build system
- vcpkg simplifies dependency management
- CMake supports both native and WASM targets
- AI can easily understand CMake structure
- Easy to add new dependencies

### 4. Platform Abstraction: SDL2
**Rule:**
- Use SDL2 for window creation, input, and OpenGL context
- Abstract platform differences (native vs WASM) in framework/core
- Use Emscripten's SDL2 port for WASM builds
- Keep platform-specific code isolated in `src/platform/`

**Why:**
- SDL2 works on both desktop and WASM (via Emscripten)
- Simple, well-documented API
- Handles window, input, and OpenGL setup
- AI can easily work with SDL2 patterns

### 5. Asset Loading: Direct File I/O
**Rule:**
- Use stb_image for sprite/texture loading
- Load assets directly from files (no complex pipeline)
- Native: Direct file I/O
- WASM: Use Emscripten's file system API or fetch API
- Keep asset formats simple (BMP/PNG/TGA, WAV)

**Why:**
- No complex asset pipeline to maintain
- Simple file formats are easy to work with
- Direct loading keeps code straightforward
- AI can easily understand file I/O patterns

### 6. Data Storage: Binary/JSON
**Rule:**
- Use simple binary formats for save games
- Use JSON for game data (enemies, items, spells) if needed
- Native: Direct file I/O
- WASM: Use IndexedDB via Emscripten's IDBFS
- Keep serialization simple (no complex frameworks)

**Why:**
- Simple formats are easier to debug
- Binary saves are fast and compact
- JSON is human-readable for game data
- AI can easily work with simple serialization

### 7. Project Architecture
**Rule:**
Organize code following this structure:

```
/arena-framework/
  /src/
    /framework/          # Core framework (minimal, engine-like)
      /core/            # Window, input, time, bootstrap
      /renderer/        # Raycaster, 2D blitter, sprite batcher
      /assets/          # Asset loading (binary, sprites, sounds)
      /math/            # Vector, matrix, math utilities
      /utils/           # Logging, file I/O, helpers
    /game/              # Your game code (this is where you build)
      /world/           # GridMap, chunk streaming, generation
      /actors/          # NPCs, enemies, player
      /items/           # Items, inventory
      /ui/              # UI rendering (2D overlay)
      /simulation/      # Gameplay systems (combat, dialogue, etc.)
    /platform/          # Platform-specific code
      /native/          # SDL2/GLFW for desktop
      /wasm/            # Emscripten bindings for web
  /assets/              # Game assets (sprites, sounds, data)
  /tools/               # Optional debug tools
  /build/               # CMake build output
  CMakeLists.txt        # Main CMake config
  vcpkg.json            # Dependency management
```

**Why:**
- Clear separation between framework and game code
- Framework stays minimal (only what game needs)
- Platform code isolated for easy maintenance
- AI can easily navigate and understand structure
- Follows vibecoding: game code drives framework

### 8. Aesthetic Direction
**Rule:**
The game should intentionally aim for a retro, TES Arena-style look:

- Raycaster rendering (2.5D perspective)
- Pixelated textures (nearest-neighbor filtering)
- Billboard sprites for NPCs and items
- Low FOV / retro camera constraints
- Simple lighting (flat shading, no complex lighting)
- Medieval/fantasy UI styling

**Why:**
- Easier to build (simple rendering algorithm)
- Fits browser performance (WASM)
- Perfect for raycaster approach
- Reduces content workload
- Matches nostalgic style
- AI can easily understand retro-style code

### 9. Deployment: Native + WASM
**Rule:**
- Framework must compile to both native desktop and WebAssembly
- Native: Standard executable (Windows/Linux/macOS)
- WASM: Emscripten-compiled JavaScript + WASM bundle
- Keep WASM bundle size reasonable (<5-10 MB)
- Use Emscripten's file preloading for assets

**Why:**
- Native for development and testing
- WASM for browser deployment
- Same codebase for both targets
- Instant playability in browser
- Shareable via simple link

## Code Quality Standards

### C++ Best Practices
1. **C++17 Standard**: Use C++17 features (no newer standards initially)
2. **No Exceptions**: Use error codes or `std::optional` for error handling
3. **Header-Only**: Prefer header-only implementations where possible
4. **Simple Types**: Use structs + functions over classes when possible
5. **RAII**: Use smart pointers and RAII for resource management
6. **Const Correctness**: Use `const` where appropriate
7. **Clear Naming**: Use descriptive names (e.g., `GridMap`, not `Map`)

### File Organization
1. **One File, One Purpose**: Each file should have a single, clear responsibility
2. **Header/Implementation Split**: Use `.h` and `.cpp` files (except header-only)
3. **Include Guards**: Use `#pragma once` or include guards
4. **Forward Declarations**: Use forward declarations to reduce includes
5. **Clear Naming**: Use descriptive names that explain purpose

### Error Handling
1. **Error Codes**: Return error codes or use `std::optional` for failures
2. **Logging**: Use the Log utility for all logging (INFO, WARN, ERROR)
3. **Validation**: Validate inputs before operations
4. **Graceful Degradation**: Handle missing features gracefully
5. **No Exceptions**: Framework code should not throw exceptions

### Memory Management
1. **Smart Pointers**: Prefer `std::unique_ptr` and `std::shared_ptr`
2. **RAII**: Use RAII for all resource management
3. **No Raw New/Delete**: Avoid raw `new`/`delete` in framework code
4. **Stack Allocation**: Prefer stack allocation for small objects
5. **Clear Ownership**: Make ownership clear in function signatures

## Testing and Debugging Requirements

### Always Test Before Completing
1. **ALWAYS compile** both native and WASM builds after making changes
2. **ALWAYS test in browser** (for WASM) and native executable
3. **ALWAYS add error handling** to critical paths (initialization, render loops)
4. **ALWAYS add debug logging** for important operations using the Log utility
5. **ALWAYS check for memory leaks** (use Valgrind or similar for native)

### Debug Utility Usage
- Use `Log::info()` for informational messages during development
- Use `Log::error()` for error conditions
- Use `Log::warn()` for warnings (performance issues, invalid inputs, etc.)
- All debug output should be controllable via compile-time flags
- WASM: Use `emscripten_log()` or `printf()` (redirects to console.log)

### Testing Checklist
Before marking any task as complete:
- [ ] Code compiles without errors (both native and WASM)
- [ ] No compiler warnings (or warnings are intentional and documented)
- [ ] Game initializes without errors (check console/logs)
- [ ] Game renders correctly (raycaster visible)
- [ ] Controls work (WASD movement, mouse look)
- [ ] No crashes during gameplay
- [ ] Performance is acceptable (60 FPS target)
- [ ] Window resize works correctly (native)
- [ ] Memory usage is reasonable (no leaks)

### Performance Monitoring
- FPS counter in debug overlay
- Frame time tracking
- Memory usage display (debug mode)
- Chunk loading/unloading metrics
- Raycaster performance profiling

### Platform Compatibility
- Test on Windows, Linux, macOS (native)
- Test in Chrome, Firefox, Safari (WASM)
- Handle WebGL context loss gracefully (WASM)
- Validate SDL2 input works on all platforms
- Use feature detection, not platform sniffing

### Build System Guidelines
- CMake configuration should be clear and well-commented
- vcpkg dependencies should be minimal
- Build should work out-of-the-box after cloning
- WASM build should produce working HTML/JS/WASM bundle
- Include build instructions in README

## AI-Assisted Development Best Practices

### Writing AI-Friendly Code
1. **Clear Intent**: Write code that clearly expresses intent - AI understands well-commented, self-documenting code
2. **Consistent Patterns**: Follow established patterns in the codebase
3. **Modular Design**: Break complex features into smaller, composable pieces
4. **Simple Types**: Use simple structs and functions - avoid complex inheritance
5. **Inline Comments**: Add comments explaining "why" not just "what"
6. **Header Documentation**: Document public APIs in headers

### Prompting Strategy
When asking AI to implement features:
- Reference specific files and line numbers
- Show examples of similar code in the codebase
- Break complex features into smaller tasks
- Ask for both header and implementation files
- Request debug logging for new features
- Specify CMake changes if needed
- Reference the phased plan when implementing features

### Code Review for AI
Before accepting AI-generated code:
1. Verify it follows project patterns
2. Check C++17 compatibility
3. Ensure WASM compatibility (no exceptions, platform checks)
4. Verify error handling is present
5. Check that debug logging is added
6. Ensure file structure matches project layout
7. Verify CMake integration if new files added

## Development Workflow

### Phased Development Approach
Follow the plan phases in order:
1. **Phase 1**: Bootstrap skeleton (window, input, time, math)
2. **Phase 2**: 2D renderer (sprite blitting, text)
3. **Phase 3**: Raycaster (DDA, wall rendering, textures)
4. **Phase 4**: Map system (chunks, generation, collision)
5. **Phase 5**: Basic gameplay (actors, player, items, combat)
6. **Phase 6**: UI layer (inventory, HUD, dialogue, menus)
7. **Phase 7**: Content pipeline (data loading, saves, quests)
8. **Phase 8**: Tools & polish (debug overlay, hot reload)

### Development Principles
1. **Start with Phase 1**: Get window + input working first
2. **Test in browser early**: Compile to WASM early to catch issues
3. **Build incrementally**: Add one feature at a time
4. **Let game drive framework**: Only add framework features when game needs them
5. **Commit often**: Git history helps Cursor understand context
6. **Use Cursor for implementation**: Write design docs, let Cursor generate code

### Build Commands
```bash
# Native build
mkdir build && cd build
cmake .. -DCMAKE_TOOLCHAIN_FILE=[vcpkg-root]/scripts/buildsystems/vcpkg.cmake
cmake --build .

# WASM build
mkdir build-wasm && cd build-wasm
emcmake cmake .. -DCMAKE_TOOLCHAIN_FILE=[vcpkg-root]/scripts/buildsystems/vcpkg.cmake -DTARGET_PLATFORM=WASM
cmake --build .
```

## Documentation Standards

### Code Comments
- Add comments for public functions/classes in headers
- Explain complex logic (especially raycaster math)
- Document why choices were made, not just what code does
- Use Doxygen-style comments for public APIs
- Comment platform-specific code paths

### File Headers
- Include a brief description at the top of complex files
- Note dependencies and relationships to other files
- Document any non-obvious patterns or conventions
- Include author/date for significant files

### README Requirements
- Build instructions (native and WASM)
- Dependency installation (vcpkg, Emscripten)
- Project structure overview
- Development workflow
- Known issues and limitations

## When Adding New Features

### Development Workflow
1. **Check the plan**: See which phase the feature belongs to
2. **Design the interface**: Create header file with public API first
3. **Implement logic**: Build implementation with error handling
4. **Add to CMake**: Update CMakeLists.txt if new files added
5. **Add debug logging**: Log important operations
6. **Test**: Verify functionality in both native and WASM
7. **Check performance**: Monitor FPS and memory usage
8. **Document**: Add comments explaining the implementation

### Feature Checklist
- [ ] Header file created with clear API
- [ ] Implementation file created (or header-only)
- [ ] Error handling added
- [ ] Debug logging included
- [ ] WASM compatibility verified (no exceptions, platform checks)
- [ ] CMake integration updated
- [ ] Code follows project structure
- [ ] No compiler warnings
- [ ] Tested in both native and WASM
- [ ] Performance acceptable

## File Structure Rules

- Keep framework code in `src/framework/`
- Keep game code in `src/game/`
- Keep platform code in `src/platform/`
- Use C++17 for all code
- Keep headers in `.h` files, implementations in `.cpp` files
- Organize by feature/domain, not by file type
- Follow the phased plan structure

## Key Principles Summary

1. **Vibecoding**: Build only what you need, start with the game
2. **WASM-First**: Code should work in both native and WASM
3. **Simple C++**: Use structs + functions, avoid complex patterns
4. **No Exceptions**: Use error codes or `std::optional`
5. **Header-Only Preferred**: Reduce compilation complexity
6. **Clear Structure**: Framework vs game code separation
7. **AI-Friendly**: Write clear, well-commented, simple code

## Success Criteria

- Framework compiles to both native and WASM
- Can render a simple raycaster dungeon
- Player can move and interact with doors
- Basic UI (inventory, HUD) works
- Assets load from files
- Game can save/load state
- Debug overlay provides useful information

Every code decision should consider: "Is this easy for AI to understand and modify? Does the game actually need this?"
